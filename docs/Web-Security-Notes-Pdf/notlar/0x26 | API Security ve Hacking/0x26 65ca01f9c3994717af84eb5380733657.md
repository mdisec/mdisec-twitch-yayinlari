# 0x26 | KanlÄ±-CanlÄ± API Security ve Hacking

Web Security dÃ¼nyasÄ±nÄ± dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼zde aslÄ±nda API Security konusu iÃ§in yeni bir durum sÃ¶z konusu deÄŸildir. Sadece web teknolojilerinin evrildiÄŸi noktadaki yaklaÅŸÄ±mlarda deÄŸiÅŸmler bulunmaktadÄ±r. Peki API gÃ¼venliÄŸi nedir ve nasÄ±l saÄŸlanÄ±r?

Web uygulamalarÄ± **`Frontend`** ve **`Backend`** olarak ikiye ayrÄ±ldÄ±ktan sonra **`Backend`** dÃ¼nyasÄ± iÃ§erisinde farklÄ± ve detaylÄ± yapÄ±lar bulunmaktadÄ±r. GeÃ§miÅŸte, bir web tarayÄ±cÄ± ile sunucu arasÄ±ndaki etkileÅŸimler genellikle basit bir request-response (istek-yanÄ±t) dÃ¶ngÃ¼sÃ¼ ÅŸeklinde gerÃ§ekleÅŸirken, gÃ¼nÃ¼mÃ¼zde arka planda onlarca farklÄ± servisle karmaÅŸÄ±k etkileÅŸimler meydana gelmektedir. Bu yeni yapÄ±, API gÃ¼venliÄŸini saÄŸlamanÄ±n hem zorunlu hem de karmaÅŸÄ±k hale getirmiÅŸtir. Ancak bu temel mimariler ve konular anlaÅŸÄ±ldÄ±ktan sonra mesele bizim iÃ§in Ã§ok da zor olmamaktadÄ±r. 

Åimdi bilgisayarÄ±mÄ±zdan gÃ¶nderilen bir HTTP talebini ele alalÄ±m. Bu talep, Ã¶ncelikle Ã¶n tarafta karÅŸÄ±laÅŸÄ±lan Load Balancer veya bir API Gateway Ã¼zerinden geÃ§er. Buradan sonra talep, belirli bir uygulamaya ulaÅŸÄ±r. Uygulama, bu talebi aldÄ±ktan sonra, birden fazla yapÄ±dan geÃ§irerek iÅŸlemektedir. Bu sÃ¼reÃ§, talebin nasÄ±l yÃ¶nlendirildiÄŸi ve iÅŸlendiÄŸi aÃ§Ä±sÄ±ndan hayati Ã¶nem taÅŸÄ±r.

```jsx
GET / HTTP/2.0
Host: website.com
User-Agent: 
```

Ã–rneÄŸin, Laravel gibi bir framework'te Ã§alÄ±ÅŸan geliÅŸtiriciler iÃ§in, gelen bir isteÄŸin hangi route'a yÃ¶nlendirileceÄŸi gibi routing iÅŸlemleri framework'ten framework'e deÄŸiÅŸiklik gÃ¶sterebilir. Ancak, iÅŸler API seviyesine geldiÄŸinde, genellikle standart bir biÃ§imlendirme kullanÄ±lÄ±r. Bu standartlaÅŸma, farklÄ± framework'ler arasÄ±nda bile uyumlu bir API tasarÄ±mÄ± ve iÅŸlevselliÄŸi saÄŸlar.

Diyelim ki bir **`User`** objeniz var ve bu obje iÃ§erisinde **`username`** ve **`firstname`** adÄ±nda iki alan (field) bulunuyor. VeritabanÄ±nda bu alanlara karÅŸÄ±lÄ±k gelen kolonlar mevcut. Bu alanlar Ã¼zerinden Create, Read, Update, Delete (CRUD) iÅŸlemleri yapÄ±lÄ±rken, istekler aÅŸaÄŸÄ±daki gibi bir formatta ele alÄ±nÄ±r. Ã–rneÄŸin, **`username`** Ã¼zerinden yapÄ±lan bir istekle bu iÅŸlemleri gerÃ§ekleÅŸtirebilirsiniz:

```jsx
GET /api/mdisec HTTP/2.0
Host: website.com
User-Agent: [Your User Agent]

username: "a-z100",
firstname: "[Desired First Name]"

```

Siz bu requestâ€™i gÃ¶nderdiÄŸiniz zaman aslÄ±nda `mdisec` olarak verdiÄŸiniz deÄŸer `{username}` fieldâ€™Ä±nÄ± ifade etmektedir. GÃ¶nderdiÄŸiniz sorgu da arka tarafta kabaca `select * from Users where username=mdisec`  gibi bir sql sorgusunu Ã§alÄ±ÅŸtÄ±rmaktadÄ±r. YazÄ±lÄ±mcÄ±lar iÃ§in bu Ã§ok kolaydÄ±r Ã§Ã¼nkÃ¼ aslÄ±nda yaptÄ±ÄŸÄ± ÅŸey `User.find($username)` gibi bir ifade kullanarak istediÄŸi iÅŸlemi gerÃ§ekleÅŸtirmektedir. 

Ancak bir de gÃ¼ncelleme (update) iÅŸlemleri yapÄ±lmaktadÄ±r. GÃ¼ncelleme (update) iÅŸlemleri iÃ§in standart bir formatÄ±n olmasÄ± Ã¶nemlidir ve genellikle iki ana yÃ¶ntem kullanÄ±lÄ±r. GeÃ§miÅŸte, tarayÄ±cÄ±larda AJAX teknolojisi bugÃ¼nkÃ¼ kadar geliÅŸmiÅŸ deÄŸilken, form alanlarÄ± genellikle sadece GET veya POST metodlarÄ±nÄ± desteklerdi. Bu form alanlarÄ±nda, metod olarak yalnÄ±zca GET ya da POST seÃ§enekleri belirtilebilirdi. POST metodunu kullanarak bir istek gÃ¶nderildiÄŸinde, isteÄŸin gÃ¶vdesinde (body) bir JSON nesnesi taÅŸÄ±nabilir. Bu JSON, sunucu tarafÄ±nda belirli bir iÅŸlemi tetiklemek iÃ§in kullanÄ±lÄ±r ve bÃ¶ylece gÃ¼ncelleme iÅŸlemleri gerÃ§ekleÅŸtirilir. Bu iÅŸlemlerin arka planda nasÄ±l iÅŸlediÄŸi ve yapÄ±landÄ±rÄ±ldÄ±ÄŸÄ±, uygulamanÄ±n iÃ§ yapÄ±sÄ±na ve kullanÄ±lan teknolojilere baÄŸlÄ±dÄ±r.

```jsx
<form method="GET/POST">
<!-- Form ElemanlarÄ± -->
</form>
```

```jsx
POST /api/{username} HTTP/2.0
Host: website.com
User-Agent: [Your User Agent]

{
    "username": "mdisec",
    "firstname": "Mehmet"
}
```

Ancak, CREATE ve UPDATE gibi farklÄ± iÅŸlemler de POST ile gerÃ§ekleÅŸtirilirdi. Bu iÅŸlemleri ayÄ±rt etmek iÃ§in eski yaklaÅŸÄ±mlarda Ã¶zel alanlar kullanÄ±lÄ±rdÄ±:

```jsx
<input type="hidden" name="_method" value="PUT">
<input type="hidden" name="_method" value="DELETE">
```

Bu teknik, formdan gelen POST isteÄŸinin, sunucu tarafÄ±nda alÄ±ndÄ±ÄŸÄ±nda PUT veya DELETE olarak iÅŸlenmesini saÄŸlar. Ancak, gÃ¼nÃ¼mÃ¼zde RESTful API tasarÄ±mÄ± sayesinde doÄŸrudan istenen HTTP metodu kullanÄ±larak daha aÃ§Ä±k ve anlaÅŸÄ±lÄ±r bir yapÄ± oluÅŸturulmuÅŸtur. Ã–rneÄŸin, bir kullanÄ±cÄ±yÄ± silmek iÃ§in DELETE metodu doÄŸrudan kullanÄ±lÄ±r: Son birkaÃ§ yÄ±l iÃ§erisinde de artÄ±k bu yapÄ±lar aÅŸaÄŸÄ±daki hali almÄ±ÅŸtÄ±r. 

```jsx
DELETE /api/{username} HTTP/2.0
Host: website.com
User-Agent: [Your User Agent]

{
    "username": "mdisec",
    "firstname": "Mehmet"
}
```

Modern yazÄ±lÄ±m mimarilerinde, bir **`UserController`** sÄ±nÄ±fÄ± genellikle CRUD iÅŸlemlerini yÃ¶netir. Bu sÄ±nÄ±fÄ±n her bir metodu, belirli bir HTTP isteÄŸine yanÄ±t olarak tanÄ±mlanabilir: Yani ÅŸunu anlamamÄ±z gerekiyor; Ã¶rneÄŸin aÅŸaÄŸÄ±daki gibi bir yapÄ±yÄ± dÃ¼ÅŸÃ¼nÃ¼rsek iÅŸlemleriniz direkt olarak bu metotlara aktarÄ±labiliyor. 

```jsx
class UserController extend Controller:
	def get():
	
	def delete():
	
	def update():
	
```

Bu yapÄ±, API tasarÄ±mÄ±nÄ± daha modular ve yÃ¶netilebilir kÄ±lar, bÃ¶ylece geliÅŸtiriciler spesifik iÅŸlemleri daha etkin ÅŸekilde gerÃ§ekleÅŸtirebilirler. Bu yaklaÅŸÄ±m, hem kodun okunabilirliÄŸini artÄ±rÄ±r hem de API'nin bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r.

```jsx
UPDATE /api/{username} HTTP/2.0
Host: website.com
User-Agent: [Your User Agent]

{
    "firstname": "Mehmet"
}

class UserController extend Controller:

	def get():
	
	def delete():
	
	def update():
```

Ã–ÄŸrendiklerimizi geniÅŸletmek adÄ±na bir sonraki Ã¶nemli konumuz servis mimarileridir. Åimdiye kadar bahsettiÄŸimiz konular genellikle baÄŸÄ±msÄ±z (standalone) uygulamalar iÃ§in geÃ§erliydi. Ancak, servis mimarilerinde iÅŸler biraz daha farklÄ± iÅŸler. Ã–rneÄŸin, bir **`update()`** metodu dÃ¼ÅŸÃ¼nÃ¼n; bu metod, kullanÄ±cÄ± adÄ± (**`username`**) ve bodyâ€™deki veriyi (blob) alÄ±r, ancak gÃ¼ncellemeyi doÄŸrudan kendisi gerÃ§ekleÅŸtirmez. Bunun yerine, sistem iÃ§erisinde bulunan ve belirli iÅŸlemleri yÃ¼rÃ¼ten bir iÃ§ servisi, yani bir kullanÄ±cÄ± servisini Ã§aÄŸÄ±rÄ±r.

Bu yapÄ±, uygulamanÄ±n bir proxy uygulamasÄ± gibi davranmaya baÅŸladÄ±ÄŸÄ±nÄ± gÃ¶sterir. Bu durumda, gÃ¼ncelleme iÅŸlemini yapan iÃ§ serviste, kullanÄ±cÄ±dan aldÄ±ÄŸÄ± fieldâ€™lar dÄ±ÅŸÄ±nda da fieldâ€™lar ekleyerek aÅŸaÄŸÄ±daki gibi bir request gidebilir:

```jsx
UPDATE /internalapi/v1/user/{username}
Hostname: internalUserService

{
	"firstname": "Mehmet",
	"additionalField": "exampleValue"
}
```

Bir hackerÄ±n bakÄ±ÅŸ aÃ§Ä±sÄ±yla dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼nÃ¼zde, ilk olarak gÃ¶nderdiÄŸiniz isteÄŸin gÃ¶vdesine (body) ekleyeceÄŸiniz alanlar (fields), aradaki uygulama tarafÄ±ndan doÄŸrudan iÃ§ servislere iletiliyorsa, gÃ¼venlik aÃ§Ä±klarÄ±na neden olabilir. Bu durumda, eÄŸer uygulama gelen verileri yeterince doÄŸrulamadan veya temizlemeden iÃ§ servislere yÃ¶nlendirirse, saldÄ±rganlar bu gÃ¼venlik zaafiyetini kullanarak sisteme zarar verebilir veya istenmeyen iÅŸlemler gerÃ§ekleÅŸtirebilirler. Bu tÃ¼r bir senaryo, Ã¶zellikle iÃ§ servislerin gelen verileri sorgulamadan iÅŸlemesi durumunda, ciddi gÃ¼venlik riskleri oluÅŸturabilir.

Ã–zellikle, kullanÄ±cÄ±lardan alÄ±nan **`hostname`** gibi deÄŸerler, uygulama tarafÄ±ndan iÃ§ sistemlere iletilmeden Ã¶nce doÄŸru bir ÅŸekilde doÄŸrulanmalÄ± ve temizlenmelidir.

AyrÄ±ca, kullanÄ±cÄ± tarafÄ±ndan gelen **`username`** alanÄ±, sistem tarafÄ±ndan sorgulanmadan doÄŸrudan iÃ§ sistemlerde kullanÄ±lÄ±rsa, kÃ¶tÃ¼ niyetli kiÅŸiler tarafÄ±ndan sistem komutlarÄ± enjekte edilebilir. Bu, gÃ¼venlik aÃ§Ä±klarÄ±nÄ± tetikleyen ciddi bir sorundur. Ã–rneÄŸin, kÃ¶tÃ¼ niyetli bir kullanÄ±cÄ± URL encoding kullanarak **`username`** alanÄ±na zararlÄ± ifadeler yerleÅŸtirebilir:

```jsx
UPDATE /api/..%2f..%2f..%2f..%2fdeleteAllUser HTTP/2.0
Host: website.com
```

Bu istek, sistem tarafÄ±ndan yanlÄ±ÅŸ anlaÅŸÄ±larak kÃ¶tÃ¼ niyetli bir iÅŸlemi tetikleyebilir. Burada kullanÄ±lan **`..%2f`** (yani URL encodingâ€™de **`/`**), dizin gezinme saldÄ±rÄ±larÄ±na olanak tanÄ±yabilir ve **`deleteAllUser`** komutunu Ã§alÄ±ÅŸtÄ±rarak sistemdeki tÃ¼m kullanÄ±cÄ±larÄ± silmeye Ã§alÄ±ÅŸabilir. Bu tip bir saldÄ±rÄ±, uygulamanÄ±n Ã¶nemli verilerini kaybetmesine veya istenmeyen sonuÃ§lara yol aÃ§abilir.

Bu nedenle, kullanÄ±cÄ±dan alÄ±nan her tÃ¼rlÃ¼ veri, uygulama tarafÄ±ndan gÃ¼venli bir ÅŸekilde iÅŸlenmeden Ã¶nce doÄŸrulama ve sanitasyon sÃ¼reÃ§lerinden geÃ§irilmelidir. Bu sÃ¼reÃ§ler, zararlÄ± veya istenmeyen verilerin sistem iÃ§erisinde iÅŸlenmesini Ã¶nlemek iÃ§in kritik Ã¶neme sahiptir.

API gÃ¼venliÄŸi, modern yazÄ±lÄ±m geliÅŸtirme dÃ¼nyasÄ±nda her geÃ§en gÃ¼n daha da bÃ¼yÃ¼k bir Ã¶nem kazanmaktadÄ±r. Web uygulamalarÄ±nÄ±n karmaÅŸÄ±k yapÄ±sÄ± ve Ã§ok katmanlÄ± servis mimarileri, gÃ¼venliÄŸi hem zorunlu hem de zor bir hale getirmiÅŸtir. Bu Ã§alÄ±ÅŸmada, API gÃ¼venliÄŸinin temel kavramlarÄ±nÄ±, potansiyel tehditleri ve korunma yÃ¶ntemlerini detaylÄ± bir ÅŸekilde ele aldÄ±k. Ã–zellikle, uygulamalar arasÄ± veri aktarÄ±mÄ±nda kullanÄ±lan metodlar ve kullanÄ±cÄ±dan alÄ±nan girdilerin nasÄ±l iÅŸlenmesi gerektiÄŸi Ã¼zerinde durduk. BunlarÄ±n yanÄ± sÄ±ra, saldÄ±rÄ± vektÃ¶rlerinin anlaÅŸÄ±lmasÄ± ve bunlara karÅŸÄ± savunma mekanizmalarÄ±nÄ±n geliÅŸtirilmesi, API gÃ¼venliÄŸinin temel taÅŸlarÄ±nÄ± oluÅŸturur.

Bu bilgiler Ä±ÅŸÄ±ÄŸÄ±nda, API gÃ¼venliÄŸi konusunda bilinÃ§li ve stratejik yaklaÅŸÄ±mlar geliÅŸtirmek mÃ¼mkÃ¼ndÃ¼r. YazÄ±nÄ±n geri kalan bÃ¶lÃ¼mlerinde, PortSwigger tarafÄ±ndan hazÄ±rlanan laboratuvar ortamlarÄ±nda gerÃ§ekleÅŸtireceÄŸimiz pratik uygulamalarla teorik bilgilerimizi pekiÅŸtireceÄŸiz. Bu sayede, hem gÃ¼venlik zaafiyetlerini daha iyi anlayacak hem de etkili koruma tekniklerini uygulama fÄ±rsatÄ± bulacaÄŸÄ±z. API gÃ¼venliÄŸi, sÃ¼rekli geliÅŸen bir alan olduÄŸundan, bu konudaki yenilikleri takip etmek ve gÃ¼ncel kalmak da bÃ¼yÃ¼k Ã¶nem taÅŸÄ±maktadÄ±r.

AÅŸaÄŸÄ±daki labâ€™larÄ±n tÃ¼mÃ¼nÃ¼ Ã§Ã¶zmeyi hedeflemekteyizâ€¦

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled.png)

## **Lab: Exploiting an API endpoint using documentation**

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%201.png)

Lab Ã§Ã¶zÃ¼mÃ¼ iÃ§in bilmemiz gereken temel bilgiler aÃ§Ä±klamada verilmiÅŸtir. API hakkÄ±nda bilmemiz gereken bu teorik bilgileri yazÄ±nÄ±n giriÅŸinde vermiÅŸ olduk. ArtÄ±k lab Ã§Ã¶zÃ¼mÃ¼ne geÃ§ebiliriz. 

Bu lab Ã¶zelinde konuÅŸacak olursak swagger.json isimli dosya bizim iÃ§in Ã¶nem taÅŸÄ±maktadÄ±r. Backend geliÅŸtiricileri bir konfigÃ¼rasyon ile tÃ¼m api metotlarÄ±nÄ±, parametrelerini, aÃ§Ä±klamalarÄ±nÄ± otomatik olarak hazÄ±rlayÄ±p swagger dosyasÄ± olarak yazÄ±lÄ±m geliÅŸtiricilerinin kullanabilmesi iÃ§in apiâ€™nin altÄ±nda bir yere koyabilmektedirler. DolayÄ±sÄ±yla ilk olarak bir api dokÃ¼mantasyonu bulmalÄ±yÄ±z.

Ã–ncelikle verilen kullanÄ±cÄ± giriÅŸ bilgileriyle sistemde oturum aÃ§alÄ±m. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%202.png)

Sisteme giriÅŸ yaptÄ±ktan sonra Email adresimizi gÃ¼ncelleyebileceÄŸimiz bir kÄ±smÄ±n olduÄŸunu gÃ¶rÃ¼yoruz.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%203.png)

Bu gÃ¼ncellemeyi yaptÄ±ÄŸÄ±mÄ±z esnada oluÅŸan request ise bu ÅŸekildedir. API ile iletiÅŸime geÃ§tiÄŸimiz yerlerden biri de aslÄ±nda burasÄ±dÄ±r. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%204.png)

Bu request iÃ§in `â€œemailâ€` fieldâ€™Ä±nÄ± hiÃ§ gÃ¶ndermediÄŸimizde backend tarafÄ±ndan hata mesajÄ± verilmektedir. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%205.png)

Burada baÅŸka bir metot bulduÄŸumuzda paramatresini bilmesek bile hata mesajÄ±nda bize bazÄ± bilgilerin verilebileceÄŸini anlamÄ±ÅŸ oluyoruz artÄ±k ğŸ™‚

Burada veritabanÄ±nda deÄŸiÅŸiklikler yaparak veriyi bozabilecek DELETE, UPDATE, PATCH gibi operatorleri kullanmak yerine okuma yapan operatorleri kullanmak daha doÄŸru olacaktÄ±r. Bu yÃ¼zden GET ile ilerleyebiliriz. 

Burada aynÄ± zamanda kullanÄ±cÄ± adÄ±nÄ± bildiÄŸimiz bir kiÅŸinin eposta adresini de gÃ¶rebildiÄŸimiz bir durum bulunmaktadÄ±r. EÄŸer bu sistemde kullanÄ±clarÄ±n eposta adresi gizli olmasÄ± gerekiyorsa IDOR zafiyetinin de varlÄ±ÄŸÄ±ndan bahsedebiliriz. 

`carlos` kullanÄ±cÄ±sÄ±nÄ± burada artÄ±k silmeyi denediÄŸimizde baÅŸarÄ±yla sildiÄŸimizi gÃ¶rebiliriz. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%206.png)

Ve lab Ã§Ã¶zÃ¼lmÃ¼ÅŸ olduâ€¦

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%207.png)

Biz burada API dokÃ¼mantasyonunu okumadan olmasÄ± gereken iÅŸlemi tahmin ederek ilerledik ancak API dokÃ¼mantasyonunu da bulmak istersek buradaki requestâ€™e bakabiliriz. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%208.png)

URLâ€™i kopyalayÄ±p tarayÄ±cÄ±mÄ±zda aÃ§arak da inceleyebiliriz. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%209.png)

DolayÄ±sÄ±yla anlattÄ±ÄŸÄ±mÄ±z temel bilgilerin farklÄ± bir bakÄ±ÅŸ aÃ§Ä±sÄ±yla kullanÄ±ldÄ±ÄŸÄ±nda nelere sebebiyet verdiÄŸini kolaylÄ±kla gÃ¶rebildiÄŸinizi umut ediyorum. 

## Lab: Exploiting server-side parameter pollution in a query string

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2010.png)

Bu lab ortamÄ±nda ise `administrator` hesabÄ±yla giriÅŸ yaparak `carlos` kullanÄ±cÄ±sÄ±nÄ± silmemiz istenmektedir. DolayÄ±sÄ±yla baÅŸlangÄ±Ã§ta yapmamÄ±z gereken ÅŸey `administrator` hesabÄ±na nasÄ±l giriÅŸ yapacaÄŸÄ±mÄ±zÄ± bulmaktÄ±r. 

ParolamÄ± unuttum (forgot-password) bÃ¶lÃ¼mÃ¼nden ilerleyerek sistemi inceleyelim. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2011.png)

OluÅŸan request bu ÅŸekildedir. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2012.png)

Bu request Ã¼zerinde bazÄ± deÄŸiÅŸiklikler yaparak sistemin nasÄ±l bir davranÄ±ÅŸ sergilediÄŸini inceleyebiliriz. Lab bilgisinde de `parameter pollution` ile ilgili ÅŸeyler sÃ¶ylendiÄŸi iÃ§in odaklanmamÄ±z gereken konu bu olmalÄ±dÄ±r. 

Bu bilgiler Ä±ÅŸÄ±ÄŸÄ±nda ilerlediÄŸimizde bizi tokenâ€™a gÃ¶tÃ¼ren yÃ¶ntemin bu olduÄŸunu gÃ¶rmÃ¼ÅŸ olduk. AÅŸaÄŸÄ±daki requestâ€™i incelerseniz bu yapÄ±yÄ± nasÄ±l kurduÄŸumuzu gÃ¶rebilirsiniz.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2013.png)

Burada yapmÄ±ÅŸ olduÄŸumuz ÅŸey aslÄ±nda APIâ€™nin nasÄ±l bir yapÄ±da olduÄŸunu anlayarak ilerlemek oldu. Ã–rneÄŸin aÅŸaÄŸÄ±daki gibi bir yapÄ±yla soru iÅŸaretinden sonra parametreler gelmekte. API standart bir formatta yazÄ±lmamÄ±ÅŸ durumda. Yani biz servisin query parametrelerine injection yapmÄ±ÅŸ oluyoruz.

```jsx
internalservice.local/api/v1/updateToken?username=carlos=1234%26
```

Normal ÅŸartlar altÄ±nda, bir kullanÄ±cÄ± adÄ± ve geÃ§erli bir CSRF (Cross-Site Request Forgery) token'iyle sÄ±nÄ±rlÄ± olmasÄ± gereken ÅŸifre sÄ±fÄ±rlama isteÄŸi, burada ekstra bir parametre ile geniÅŸletilmiÅŸ. Request gÃ¶vdesinde yer alan **`username=administrator&field=reset_token&#`** ifadesi, bu ekstra parametrenin, sistem tarafÄ±ndan yeni bir 'reset token' oluÅŸturulmasÄ±na yol aÃ§masÄ±nÄ± saÄŸlayabilir. Bu, URL'de kullanÄ±lan **`&`** karakteri ile yeni bir parametre eklenerek yapÄ±lmÄ±ÅŸ bir parametre enjeksiyonudur. Ve bize reset_token deÄŸerini vermektedir.

DolayÄ±sÄ±yla burada elde ettiÄŸimiz token ile artÄ±k parola sÄ±fÄ±rlama ekranÄ±na gidebiliriz.

```jsx
https://0a8a00a104c5065781a6fd000057009f.web-security-academy.net/forgot-password?reset_token=gexffyv3mhm0j10lhlmw3i7hwbd1nzzp
```

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2014.png)

Administrator hesabÄ± iÃ§in yeni parolayÄ± belirledikten sonra artÄ±k sisteme giriÅŸ yapalÄ±m.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2015.png)

Ve Carlos kullanÄ±cÄ±sÄ±nÄ± silelim.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2016.png)

Ve lab Ã§Ã¶zÃ¼lmÃ¼ÅŸ oldu.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2017.png)

## **Lab: Finding and exploiting an unused API endpoint**

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2018.png)

Bu lab ortamÄ±nda da gizli ya da kullanÄ±lmayan bir API endpoint'ini kullanarak bir "Lightweight l33t Leather Jacket" satÄ±n almamÄ±z gerekiyor. Ã–ncelikle sisteme giriÅŸ yaparak ilerleyelim. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2019.png)

Bahsedilen Ã¼rÃ¼ne gittiÄŸimizde oluÅŸan request ve response bu ÅŸekildedir. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2020.png)

EÄŸer "1" deÄŸeri deÄŸiÅŸtirildiÄŸinde sistem bir hata veriyorsa, bu durum genellikle isteÄŸi iÅŸleyen sunucu tarafÄ±ndaki bir HTTP istemcisinin (HTTP client) beklentilerine uygun olmayan bir girdi ile karÅŸÄ±laÅŸtÄ±ÄŸÄ±nÄ± gÃ¶sterir. Sunucunun iÃ§erisinde Ã§alÄ±ÅŸan bu HTTP istemci, belki de bu girdiyi bir baÅŸka hizmete veya API'ye iletme gÃ¶revinde bulunmakta ve bu geÃ§ersiz girdi sebebiyle de hata Ã¼retmekte olabilir. DolayÄ±sÄ±yla biz bu deÄŸer Ã¼zerinden ilerlemeliyiz.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2021.png)

Sistemin bizden ne istediÄŸini dÃ¼ÅŸÃ¼necek olursak almamÄ±z gereken Ã¼rÃ¼n iÃ§in yeterli paranÄ±n kasada bulunmadÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2022.png)

DolayÄ±sÄ±yla alacaÄŸÄ±mÄ±z Ã¼rÃ¼nÃ¼n fiyatÄ±nÄ± deÄŸiÅŸtirebildiÄŸimiz bir yapÄ±yÄ± dÃ¼ÅŸÃ¼nebiliriz.

Almak istediÄŸimiz Ã¼rÃ¼nÃ¼ Ã¶ncelikle sepetimize ekleyelim.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2023.png)

EklediÄŸimiz Ã¼rÃ¼nÃ¼n `productId` deÄŸeri 1 olarak belirlenmiÅŸ durumda.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2024.png)

DolayÄ±sÄ±yla productId deÄŸeri 1 olan Ã¼rÃ¼nÃ¼n fiyatÄ±nÄ± da aÅŸaÄŸÄ±daki request ile 0$ olarak gÃ¼ncelleyebiliriz.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2025.png)

ArtÄ±k bu Ã¼rÃ¼nÃ¼ sepetimizden silip gÃ¼ncellenmiÅŸ fiyatÄ±yla satÄ±n alÄ±rsak labâ€™Ä± baÅŸarÄ±yla Ã§Ã¶zmÃ¼ÅŸ oluruzâ€¦

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2026.png)

## Lab: Exploiting server-side parameter pollution in a REST URL

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2027.png)

Bu lab ortamÄ± iÃ§in de tekrar `administrator` hesabÄ±yla giriÅŸ yapÄ±p `carlos` kullanÄ±cÄ±sÄ±nÄ± silmemiz istenmektedir. 

Ã–ncelikle parola sÄ±fÄ±rlama iÃ§in gerekli olan URL bilgisini ilgili js dosyasÄ±ndan Ã¶ÄŸrenelim.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2028.png)

Path bilgisini buradan Ã¶ÄŸrendiÄŸimize gÃ¶re taslak requestimizi oluÅŸturabiliriz.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2029.png)

Ãœzerinde deÄŸiÅŸiklikler yaparak bizi sonuca gÃ¶tÃ¼recek olan requestâ€™imiz ise bu ÅŸekilde.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2030.png)

Ãœst dizinlere Ã§Ä±kÄ±p kÃ¶k dizine ulaÅŸtÄ±ÄŸÄ±mÄ±zÄ± gÃ¶rebiliriz artÄ±k.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2031.png)

burada artÄ±k alt dizinleri de tespit ederek ilerliyoruz. Ã–rneÄŸin api1 ifadesi gibi yanlÄ±ÅŸ bir ifade girdiÄŸimizde sistem hata vermektedir. 

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2032.png)

Ancak bunu api olarak dÃ¼zelttiÄŸimizde bir dizini daha bulduÄŸumuzu anlayabiliriz. Bu mantÄ±kla alt dizinlere kadar gitmemiz gerekmektedir.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2033.png)

YaptÄ±ÄŸÄ±mÄ±z onlarca denemeden sonra bize bir sonuÃ§ getiren doÄŸru pathâ€™in aÅŸaÄŸÄ±daki gibi olduÄŸunu gÃ¶rmekteyiz.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2034.png)

Buradaki fieldâ€™larÄ± kullanarak bilgi edinebildiÄŸimiz bir yapÄ±ya ulaÅŸmÄ±ÅŸ durumdayÄ±z. Ä°fademizin sonuna # iÅŸaretini koymamÄ±zÄ±n sebebi de geriye kalan kÄ±smÄ±n geÃ§ersiz kÄ±lÄ±nmasÄ±nÄ± saÄŸlamak iÃ§indir.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2035.png)

DolayÄ±sÄ±yla buradan token bilgisini elde edebileceÄŸimiz fieldâ€™Ä± bulmalÄ±yÄ±z. Burada bize sonuÃ§ gelmesi iÃ§in aynÄ± zamanda daha Ã¶nce bir parola sÄ±fÄ±rlama isteÄŸi de gÃ¶ndermiÅŸ olmalÄ±yÄ±z. ArtÄ±k tokenâ€™a eriÅŸebilirizâ€¦

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2036.png)

Bu token ile parola sÄ±fÄ±rlama sayfasÄ±na gidebiliriz.

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2037.png)

ArtÄ±k parolayÄ± sÄ±fÄ±rladÄ±ÄŸÄ±mÄ±z iÃ§in sisteme administrator hesabÄ±yla giriÅŸ yapÄ±p carlos kullanÄ±cÄ±sÄ±nÄ± silebiliriz. Ve lab Ã§Ã¶zÃ¼lmÃ¼ÅŸ olduâ€¦

![Untitled](0x26%2065ca01f9c3994717af84eb5380733657/Untitled%2038.png)